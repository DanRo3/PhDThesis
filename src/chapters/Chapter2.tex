\chapter{Análisis, diseño e implementación de la propuesta de solución}
\label{chap:chapter2}

%\section*{Introducción}
%\addcontentsline{toc}{section}{Introducción}
Este capítulo presenta la propuesta de solución para abordar el problema identificado en la investigación: la interpretación y contextualización de datos no estructurados del transporte marítimo extraídos del Diario de la Marina (1844–1960). Aquí se detallan los requisitos funcionales (RF) y no funcionales (RNF) que el sistema debe cumplir, así como una descripción exhaustiva de la solución propuesta, incluyendo las historias de usuario y las tarjetas CRC (Clase-Responsabilidad-Colaboración). Además, se analizan los patrones arquitectónicos y de diseño seleccionados para estructurar la aplicación, junto con las buenas prácticas de codificación asociadas a las tecnologías empleadas. Finalmente, se incluyen el diagrama de clases y el diagrama de componentes, que ilustran los elementos clave que integran esta propuesta. Este capítulo sienta las bases técnicas y conceptuales para la implementación y validación descritas en capítulos posteriores, alineándose con los objetivos específicos de diseño e implementación establecidos en la introducción.

\section{Descripción de la Propuesta de Solución}
\label{sec:propuesta_solucion}

La solución propuesta aborda la interacción con los datos históricos del transporte marítimo del \textit{Diario de la Marina} (1844-1960) mediante el desarrollo de una aplicación web moderna, separando claramente las responsabilidades entre la interfaz de usuario, la lógica de negocio y el procesamiento avanzado de lenguaje natural. Esta arquitectura se compone de tres elementos principales: un \textit{frontend} desarrollado con React js, un \textit{backend} API construido con Django REST Framework(DRF), y un microservicio dedicado que alberga el sistema multiagente conversacional basado en inteligencia artificial y que se expone con una api creada con FastApi. 
%Esta elección arquitectónica promueve la escalabilidad, la mantenibilidad y la separación de intereses, permitiendo que cada componente evolucione de forma independiente.

% Incluye aquí tu nueva figura de arquitectura web
\begin{figure}[htbp] % h: here, t: top, b: bottom, p: page of floats - ajusta según necesidad
	\centering
	% Asegúrate de que la ruta 'images/arquitectura_web.png' sea correcta
	\includegraphics[width=0.9\textwidth]{images/micro.png} 
	\caption{Estructura de la propuesta de solución (Fuente: elaboración propia).}
	\label{fig:arquitectura_web}
\end{figure}

La Figura \ref{fig:arquitectura_web} ilustra la arquitectura general. El flujo de interacción del usuario es el siguiente:

\begin{enumerate}
	\item El usuario interactúa con la interfaz web desarrollada en React, donde ingresa sus consultas en lenguaje natural (e.g., “¿Qué barcos llegaron de Europa en enero de 1850?”).
	\item El \textit{frontend} React envía la consulta del usuario, típicamente como una petición HTTPS, al \textit{endpoint} correspondiente del \textit{backend} de DRF.
	\item El \textit{backend} de DRF actúa como orquestador principal de la lógica de negocio. Puede gestionar autenticación de usuarios (si aplica), almacenar historial de conversaciones, y, crucialmente, procesa la solicitud entrante. Determina que la consulta requiere procesamiento por IA y la reenvía al microservicio del sistema multiagente a través de una llamada API.
	\item El microservicio del sistema multiagente recibe la consulta y ejecuta su lógica interna basada en agentes para procesar el lenguaje natural, buscar en la base de datos vectorial del \textit{Diario de la Marina}, contextualizar la información y generar la respuesta (texto y/o imágenes).
	\item El microservicio del sistema multiagente devuelve el resultado procesado al \textit{backend} de DRF.
	\item El \textit{backend} de DRF recibe la respuesta del microservicio, la formatea si es necesario (e.g., preparándola para la visualización), y la envía de vuelta al frontend React.
	\item Finalmente, el \textit{frontend} React recibe la respuesta del \textit{backend} de DRF y la presenta al usuario de forma clara y ordenada en la interfaz de chat, mostrando el texto y/o las imágenes generadas.
\end{enumerate}

Dentro del microservicio sistema multiagente opera la lógica conversacional avanzada, cuyo flujo interno se detalla a continuación y se ilustra en la Figura \ref{fig:flujo_mas_interno}. Este microservicio está diseñado específicamente para transformar los datos históricos no estructurados del \textit{Diario de la Marina} en conocimiento estructurado y accesible, superando las limitaciones de herramientas previas mediante la integración de LLMs\footnote{LLM (Large Language Model): Modelo de lenguaje de gran tamaño entrenado con enormes volúmenes de datos textuales, capaz de comprender y generar lenguaje natural con un alto nivel de coherencia, usado en tareas como la traducción automática, el resumen de textos o la generación de respuestas conversacionales.}, RAG\footnote{RAG (Retrieval-Augmented Generation): Técnica que combina modelos generativos con mecanismos de recuperación de información, permitiendo al modelo acceder a fuentes externas relevantes durante la generación de respuestas, mejorando así la precisión y actualidad de los resultados producidos.} y una coordinación eficiente entre agentes especializados.

\begin{figure}[htbp] 
	\centering
	\includegraphics[width=1\textwidth]{images/mas-final.png} 
	\caption{Flujo Interno del Microservicio Multiagente Conversacional (Fuente: elaboración propia).}
	\label{fig:flujo_mas_interno}
\end{figure}

El proceso interno del microservicio (Figura \ref{fig:flujo_mas_interno}) inicia cuando recibe una consulta del \textit{backend} DRF. Esta consulta es manejada por el Agente Moderador, que actúa como coordinador central dentro del microservicio. El Agente Moderador extrae palabras clave (e.g., “barcos”, “Europa”, “enero 1850”) y determina la intención del usuario. En la mayoría de los casos, delega la tarea de búsqueda al Agente PandasAi, que realiza la extracción de datos estructurados (como fechas, nombres de capitanes, puertos) desde el archivo CSV que contiene los datos procesados del \textit{Diario de la Marina}. Solo en casos específicos, cuando la consulta requiere información detallada sobre el contenido de la carga de los barcos, el Agente Moderador coordina con el Agente Recuperador, que convierte las palabras clave en \textit{embeddings} y consulta la base de datos vectorial especializada para recuperar fragmentos relevantes. Los datos recuperados, ya sea por el Agente PandasAi o el Agente Recuperador, se devuelven al Agente Moderador.
Posteriormente, el Agente Moderador envía la información recuperada, junto con la intención del usuario, al Agente Contextualizador. Este agente evalúa si se necesita una respuesta textual, una visualización gráfica (e.g., un gráfico de la frecuencia de llegada de barcos por mes), o ambas. Si se requieren gráficos, el Agente Contextualizador genera instrucciones que se envían al Agente PandasAi. Este agente crea un script Python para generar la visualización, valida su corrección y genera una imagen (e.g., PNG). La imagen resultante se retorna al Agente Contextualizador. Si no se requieren gráficos, el Agente Contextualizador enriquece la información textual. Antes de enviar la respuesta final al \textit{backend} DRF, el Agente Validacion revisa la coherencia y precisión del contenido generado (texto y/o imagen), comparándolo con la consulta original. Finalmente, el Agente Moderador ensambla la respuesta validada y la retorna como salida del microservicio.
Esta arquitectura desacoplada, combinando una interfaz web moderna, un backend robusto y un microservicio especializado en IA, no solo facilita la interacción del usuario y la gestión de datos, sino que también optimiza la investigación histórica, contribuye a la preservación del patrimonio documental y permite escalar los componentes de IA de forma independiente.


\section{Análisis de requisitos}

El análisis de requisitos da como resultado la especificación de las características operativas del software. Indica la interfaz de este y otros elementos del sistema, y establece las restricciones que limitan al software \cite{pressman2010practitioner}.Es una fase crucial en el proceso de desarrollo de software. Se trata de una etapa inicial en la cual un analista busca entender las necesidades del cliente y traducirlas en un conjunto de requisitos claros y bien definidos \cite{palli2023analisis}.

\subsection{Técnicas de captura de requisitos}

La definición de los requisitos del sistema se fundamenta en un proceso sistemático de captura, basado en dos técnicas ampliamente reconocidas en ingeniería de software: la entrevista y la observación, aplicadas en el contexto de los ejemplos analizados en el estado del arte (Capítulo 1). Estas técnicas, permitieron identificar las expectativas de los usuarios potenciales y las limitaciones de las soluciones existentes, asegurando que los requisitos reflejen tanto las demandas prácticas como las carencias técnicas observadas~\cite{sommerville2011software}.

\textbf{Entrevista:} Se realizaron entrevistas semiestructuradas con historiadores y académicos especializados en historia del Caribe, quienes serían usuarios finales del sistema. Las preguntas se diseñaron para explorar sus necesidades al interactuar con documentos históricos digitalizados, como el \textit{Diario de la Marina}. Por ejemplo, se les consultó: ``¿Qué tipo de información busca con mayor frecuencia en archivos históricos?'' y ``¿Qué dificultades encuentra al analizar datos marítimos de textos antiguos?''. Las respuestas destacaron la importancia de obtener respuestas contextualizadas (e.g., vinculadas a eventos históricos), la necesidad de visualizaciones gráficas para patrones comerciales y la frustración con errores de transcripción que dificultan el análisis. Estas aportaciones guiaron la definición de requisitos como la corrección de datos y la generación de gráficos.

\textbf{Análisis de Sistema Homólogos:} Mediante el análisis de sistemas existentes es
posible estudiar aplicaciones similares a la que se necesita obtener. Cuando se tiene
la concepción del funcionamiento de un software similar en cuanto a funcionalidades
y características es más sencillo identificar los requisitos del sistema que se necesita
implementar. Durante la investigación se realizó un estudio de aplicaciones similares
a la solución a desarrollar, en las cuales se observaron los diseños de sus interfaces,
las funcionalidades que ofrecen, el grado de dificultad a la hora de interactuar con
la aplicación, entre otros rasgos importantes que contribuyeran a obtener un
producto con la mejor calidad posible~\cite{sommerville2011software}. Como fuente importante
para la obtención de requisitos principales del sistema a desarrollar, se encuentra el
análisis a fondo de los sistemas homólogos estudiados y antes descritos en el
epígrafe 1.2.\\
La combinación de entrevistas y observación permitió comprender las necesidades de los usuarios con las deficiencias técnicas de las soluciones actuales, proporcionando una base sólida para los requisitos funcionales y no funcionales que se detallan a continuación.



\subsection{Requisitos funcionales}

Son declaraciones de los servicios que debe proporcionar el sistema, de la manera en que
éste debe reaccionar a entradas particulares y de cómo se debe comportar en situaciones
particulares. En algunos casos, los requerimientos funcionales de los sistemas también
pueden declarar explícitamente lo que el sistema no debe hacer~\cite{sommerville2011software}.

A continuación, se describen los requisitos funcionales específicos para el sistema multiagente conversacional propuesto:

\begin{longtable}{@{}l >{\raggedright\arraybackslash}p{4.5cm} >{\raggedright\arraybackslash}p{6.5cm} l l@{}} % Ajustados anchos
	\caption{Tabla de Requisitos Funcionales (RF)} \label{tab:requisitos_funcionales_final} \\ 
	\toprule
	\textbf{ID} & \textbf{Nombre} & \textbf{Descripción} & \textbf{Complejidad} & \textbf{Prioridad} \\ 
	\midrule
	\endfirsthead 
	
	\caption[]{Tabla de Requisitos Funcionales (RF) (Continuación)} \\ 
	\toprule
	\textbf{ID} & \textbf{Nombre} & \textbf{Descripción} & \textbf{Complejidad} & \textbf{Prioridad} \\ 
	\midrule
	\endhead 
	
	\bottomrule
	\multicolumn{5}{r@{}}{\textit{Continúa en la siguiente página...}} \\ 
	\endfoot 
	
	\bottomrule
	\endlastfoot 
	
	% --- Gestión de Usuarios y Autenticación ---
	\textbf{RF 1} & Registrar usuario & Permitir a un visitante registrarse proporcionando datos válidos (e.g.,nombre de usuario, email, contraseña), que serán almacenados de forma segura por el backend. & Media & Alta \\ 
	\textbf{RF 2} & Autenticar usuario & Permitir a un usuario registrado iniciar sesión proporcionando credenciales válidas, verificadas por el backend, generando una sesión activa. & Media & Alta \\ 
	\textbf{RF 3} & Cerrar sesión & Permitir al usuario autenticado finalizar su sesión activa en el sistema. & Baja & Media \\ 
	% --- Gestión de Conversaciones ---
	\textbf{RF 4} & Iniciar conversación & Permitir al usuario autenticado crear una nueva sesión de chat independiente de las anteriores. & Baja & Alta \\ % NUEVO
	\textbf{RF 5} & Listar conversación & Mostrar al usuario autenticado una lista de sus conversaciones previas para poder seleccionarlas y revisarlas. & Media & Media \\ % NUEVO
	\textbf{RF 6} & Visualizar conversación & Permitir al usuario seleccionar una conversación de su historial para visualizarla y continuarla. & Media & Media \\ % NUEVO
	\textbf{RF 7} & Eliminar conversación & Permitir al usuario eliminar permanentemente una conversación específica de su historial. & Media & Baja \\ 
	% --- Interfaz y Flujo del Chat ---
	\textbf{RF 8} & Insertar consulta & Permitir al usuario escribir y enviar una consulta en lenguaje natural dentro de la conversación activa. & Baja & Alta \\ 
	\textbf{RF 9} & Visualizar mensajes & Mostrar de forma clara y ordenada el diálogo (consultas del usuario y respuestas del sistema) dentro de la conversación activa. & Media & Alta \\  
	% --- Procesamiento Interno del Microservicio MAS ---
	\textbf{RF 10} & Recibir consulta & El microservicio MAS debe recibir la consulta para iniciar el flujo de agentes. & Media & Alta \\ 
	\textbf{RF 11} & Analizar consulta & El Agente Moderador debe analizar la consulta para identificar términos clave relevantes. & Alta & Alta \\ 
	\textbf{RF 12} & Determinar acción & El Agente Moderador debe interpretar el propósito principal de la consulta del usuario para determinar la próxima acción del sistema (información, análisis,gráficas estadísticas etc.). & Alta & Alta \\ 
	\textbf{RF 13} & Generar embeddings & El Agente Recuperador debe convertir las palabras clave en representaciones vectoriales (embeddings) adecuadas para la búsqueda semántica. & Alta & Alta \\ 
	\textbf{RF 14} & Consultar base de datos & El Agente Recuperador debe buscar y obtener fragmentos de texto relevantes del \textit{Diario de la Marina} desde la base de datos vectorial, basándose en los embeddings. & Alta & Alta \\
	\textbf{RF 15} & Consultar CSV & El Agente PandasAi debe buscar y obtener fragmentos de texto relevantes del \textit{Diario de la Marina} desde la base de datos en formato csv. & Alta & Alta \\ 
	\textbf{RF 16} & Contextualizar respuesta & El Agente Contextualizador debe generar una respuesta coherente en lenguaje natural, integrando la información recuperada y añadiendo contexto histórico si es pertinente. & Alta & Alta \\ 
	\textbf{RF 17} & Identificar estadísticas & El Agente Contextualizador debe determinar si la consulta o los datos recuperados justifican la creación de una representación gráfica. & Media & Media \\ 
	\textbf{RF 18} & Formular instrucciones para gráfico & Si se requiere un gráfico, el Agente Contextualizador debe generar las especificaciones (tipo de gráfico, datos a usar) para el Agente PandasAi. & Alta & Alta \\ 
	\textbf{RF 19} & Generar script & El Agente PandasAI debe crear un script ejecutable que produzca la visualización solicitada a partir de los datos y especificaciones. & Alta & Alta \\ 
	\textbf{RF 20} & Validar script & El Agente PandasAi debe verificar que el script generado es sintácticamente correcto y no contiene errores obvios antes de ejecutarlo. & Alta & Alta \\ 
	\textbf{RF 21} & Generar imagen & El Agente PandasAi debe ejecutar el script validado para generar la visualización como un archivo de imagen (e.g., PNG, JPG). & Alta & Alta \\ 
	\textbf{RF 22} & Combinar resultados & El Agente Contextualizador (o Moderador) debe combinar la respuesta textual y/o la imagen generada en una estructura de respuesta unificada. & Alta & Alta \\ 
	\textbf{RF 23} & Validar respuesta & El Agente de Validación debe revisar la respuesta preliminar para asegurar su precisión, coherencia con la consulta y ausencia de información errónea. & Alta & Alta \\  
	\textbf{RF 24} & Enviar respuesta & El microservicio MAS debe enviar la respuesta final ensamblada al backend a través de su API. & Media & Alta \\ 
	% --- Flujo de Respuesta Backend y Frontend ---
	\textbf{RF 25} & Visualizar respuesta & El backend debe enviar la respuesta (texto y/o referencia a la imagen) al frontend para su visualización. & Media & Alta \\ 
	
\end{longtable}

\subsection{Requisitos no funcionales}

Los requisitos no funcionales son aquellos que no se refieren directamente a las funciones
específicas que proporciona el sistema, sino a las propiedades de este como fiabilidad,
tiempo de respuesta y la capacidad de almacenamiento. Incluyen además restricciones de
tiempo, sobre el proceso de desarrollo y estándares~\cite{sommerville2011software}.
A continuación, se definen los requisitos no funcionales que debe cumplir la aplicación
basándose en los establecido por las normas ISO 25000 Calidad del Producto de Software,
específicamente la ISO/IEC 25010 que define las características de calidad que se tienen
en cuenta al evaluar las propiedades de un producto de software~\cite{iso25010-2023}.
A continuación, se listan los requisitos no funcionales identificados:

\begin{longtable}{@{}p{2cm}p{12cm}@{}}
	\caption{Requisitos No Funcionales (RNF)} \label{tab:rnf_iso25010} \\
	\toprule
	\textbf{ID} & \textbf{Descripción} \\
	\midrule
	\endfirsthead
	
	\caption[]{Requisitos No Funcionales (RNF) (continuación)} \\
	\toprule
	\textbf{ID} & \textbf{Descripción} \\
	\midrule
	\endhead
	
	\bottomrule
	\endfoot
	
	% --- RENDIMIENTO ---
	\multicolumn{2}{@{}l}{\textbf{RNF 1: Rendimiento}} \\[0.5ex]
	RNF 1.1 & Tiempo de respuesta para consultas simples (búsqueda de barcos por nombre o fecha) no superior a los 30 segundos para 20 usuarios concurrentes. \\
	RNF 1.2 & Tiempo de respuesta para consultas complejas con generación de gráficos no superior a un minuto para 20 usuarios concurrentes. \\
	\addlinespace
	
	% --- SEGURIDAD ---
	\multicolumn{2}{@{}l}{\textbf{RNF 2: Seguridad}} \\[0.5ex]
	RNF 2.1 & Almacenamiento seguro de contraseñas de usuarios \\
	RNF 2.2 & Rastreabilidad de decisiones tomadas por los agentes IA \\
	RNF 2.3 & El acceso a la información debe estar restringido por usuario, contraseña.\\
	\addlinespace
	
	% --- USABILIDAD ---
	\multicolumn{2}{@{}l}{\textbf{RNF 3: Usabilidad}} \\[0.5ex]
	RNF 3.1 & Retroalimentación visual durante el procesamiento de consultas \\
	RNF 3.2 & Mensajes de error claros y comprensibles para usuarios \\
	\addlinespace
	
	% --- FIABILIDAD ---
	\multicolumn{2}{@{}l}{\textbf{RNF 4: Fiabilidad}} \\[0.5ex]
	RNF 4.1 & Alta disponibilidad del sistema completo \\
	RNF 4.2 & El sistema debe ser tolerante a fallos, y mostrar solo la información necesaria para orientar al usuario\\
	\addlinespace
		
	% --- MANTENIBILIDAD ---
	\multicolumn{2}{@{}l}{\textbf{RNF 5: Mantenibilidad}} \\[0.5ex]
	RNF 5.1 & El software estará bien documentado de forma tal que el tiempo de mantenimiento
	sea mínimo en caso de necesitarse. \\
	RNF 5.2 & Se debe hacer uso de los estándares de codificación definidos para el sistema multiagente \\
	RNF 5.3 & Gestión controlada de dependencias \\
	\addlinespace
	
\end{longtable}


\subsection{Historias de usuarios}

Las historias de usuario (HU) son descripciones breves y simples de los requerimientos de un cliente o usuario, que facilitan la comunicación con los desarrolladores del proyecto. Estas historias permiten expresar las expectativas y necesidades de los usuarios de una manera clara y comprensible, evitando ambigüedades y malentendidos que podrían llevar a pérdidas de tiempo y recursos \cite{menzinsky2018historias}.

Se realiza una HU por cada RF del componente, a continuación, se mostrarán las HU más relevantes. Para consultar el resto de las historias de usuario, se remite al \textbf{Anexo A}, donde se presentan de forma completa y organizada. Estas historias complementan la visión general del sistema y permiten una comprensión más exhaustiva de los requerimientos funcionales detallados.

% ==========================================
% Funcionalidad Principal del Chat y MAS
% ==========================================

\begin{userstory}[hu:08]
	\storyname{Interactuar con el chat activo (Enviar Consulta y Ver Respuesta)}
	\storyuser{Usuario autenticado}
	\storyiter{1} % Iteración ajustada
	\storypriority{Alta} % Basado en RF9 (Input), RF10, RF26, RF27, RF28
	\storyrisk{Medio} % Riesgo en la comunicación FE-BE-MAS
	\storypoints{2 semanas} % Estimación ajustada (cubre FE y BE básico)
	\storyprogrammer{Daniel Rojas Grass}
	\storydescription{
		Como usuario autenticado, quiero poder escribir una consulta en lenguaje natural en la interfaz de chat, enviarla al sistema, y ver tanto mi consulta como la respuesta del sistema (texto y/o imagen) mostradas de forma clara y ordenada en el área de diálogo de la conversación activa. (Corresponde principalmente a RF9-Input, RF10, RF26, RF27, RF28)
		
		\textbf{Precondiciones:}
		\begin{itemize}
			\item El usuario tiene una sesión activa.
			\item El usuario tiene una conversación activa (nueva HU:04 o cargada HU:06).
			\item El \textit{frontend}, el \textit{backend} y el microservicio MAS están operativos y pueden comunicarse entre sí.
		\end{itemize}
		
		\textbf{Flujo de acción:}
		\begin{enumerate}
			\item Usuario escribe una consulta en el campo de texto del chat.
			\item Usuario envía la consulta (click en botón 'Enviar' o presiona 'Enter').
			\item El \textit{frontend} muestra inmediatamente la consulta del usuario en el área de diálogo (marcada como del usuario).
			\item El \textit{frontend} envía la consulta y el ID de la conversación activa (si existe) al \textit{backend}.
			\item (Flujo cubierto en HU:09 y HU:10) El \textit{backend} recibe la consulta, la envía al microservicio MAS para procesamiento, recibe la respuesta del MAS (texto y/o referencia a imagen) y la almacena en la BD asociada a la conversación (RF9-Persistencia).
			\item El \textit{backend} envía la respuesta procesada (texto y/o URL/datos de imagen) al frontend.
			\item El \textit{frontend} recibe la respuesta del backend.
			\item El \textit{frontend} muestra la respuesta del sistema (texto y/o imagen) en el área de diálogo (marcada como del sistema).
		\end{enumerate}
	}
	\storyobservation{
		La interfaz debe indicar visualmente cuándo el sistema está procesando la respuesta. El manejo de errores (fallos de red, errores del MAS) debe ser robusto, mostrando mensajes apropiados al usuario. La visualización del chat debe permitir scroll para ver mensajes antiguos.
	}
	\storyinterface{Interfaz principal del Chat en el sitio web mostrando diálogo:
		\par\medskip % Añade un pequeño espacio vertical
		\begin{center} % Para centrar la imagen
			\includegraphics[width=0.6\textwidth]{images/chat.PNG} % Imagen del ejemplo
		\end{center}
		\medskip
	}
	
\end{userstory}

\begin{userstory}[hu:09]
	\storyname{Obtener respuesta textual relevante del MAS}
	\storyuser{Usuario autenticado (indirectamente, a través del sistema)}
	\storyiter{2} % Iteración estimada
	\storypriority{Alta} % Basado en RF11-16, RF22-25
	\storyrisk{Alto} % Riesgo asociado a la calidad/precisión de la IA
	\storypoints{4 semanas} % Estimación basada en ejemplo (complejidad alta)
	\storyprogrammer{Daniel Rojas Grass}
	\storydescription{
		Como sistema (actuando en nombre del usuario), quiero que el microservicio MAS procese una consulta recibida del \textit{backend}, la analice (palabras clave, intención), recupere información relevante del Diario de la Marina desde la BD vectorial, sintetice una respuesta textual coherente y contextualizada, la valide y la devuelva al \textit{backend}, para que el usuario final reciba información precisa. (Corresponde al flujo interno del MAS: RF11, RF12, RF13, RF14, RF15, RF16, RF22, RF23, RF24, RF25)
		
		\textbf{Precondiciones:}
		\begin{itemize}
			\item El microservicio MAS (FastAPI) está operativo.
			\item Todos los agentes internos (Moderador, Pandasai, Contextualizador, Validación) están implementados y disponibles.
			\item La base de datos vectorial (Faiss) está cargada con los datos del *Diario de la Marina* y es accesible.
			\item El csv con los datos del \textit{Diario de la Marina} esta cargado y es accesible.
			\item El LLM subyacente está configurado y accesible.
			\item El MAS recibe una solicitud válida del \textit{backend} a través de su API.
		\end{itemize}
		
		\textbf{Flujo de acción (interno del MAS):}
		\begin{enumerate}
			\item MAS recibe la consulta vía API (RF11).
			\item Agente Moderador extrae palabras clave y determina intención (RF12, RF13).
			\item Agente Recuperador genera \textit{embeddings} y busca en BD vectorial (RF14, RF15).
			\item Agente PandasAi genera tanto gráficas como búsquedas de análisis en el csv.
			\item Agente Contextualizador recibe fragmentos relevantes y genera respuesta textual inicial, añadiendo contexto (RF16).
			\item (Si no se requiere gráfico) Agente Contextualizador (o Moderador) prepara la respuesta textual preliminar (RF22).
			\item Agente Validación revisa coherencia, relevancia y posible toxicidad/error (RF23).
			\item Agente Moderador ensambla la respuesta textual validada en formato JSON (RF24).
			\item MAS retorna la respuesta JSON al backend DRF (RF25).
		\end{enumerate}
	}
	\storyobservation{
		La calidad de los embeddings y la estrategia de recuperación son críticas (RF14, RF15). La capacidad del LLM para sintetizar y contextualizar sin "alucinar" es fundamental (RF16). El agente de validación es clave para la fiabilidad (RF23). La latencia del proceso completo debe ser aceptable (considerar RNF).
	}
	\storyinterface{[N/A - Proceso interno del Microservicio MAS]}
	
\end{userstory}

\begin{userstory}[hu:10]
	\storyname{Recibir visualización gráfica cuando sea pertinente}
	\storyuser{Usuario autenticado}
	\storyiter{3} % Iteración estimada
	\storypriority{Media} % Basado en RF17-21
	\storyrisk{Moderado} % Riesgo en la generación y validación del script/gráfico
	\storypoints{2 semanas} % Estimación basada en ejemplo (complejidad alta)
	\storyprogrammer{Daniel Rojas Grass}
	\storydescription{
		Como usuario autenticado, quiero que cuando mi consulta o la información recuperada sugieran la necesidad de una visualización (e.g., análisis de tendencias, comparación de datos), el sistema (específicamente el MAS) genere un gráfico apropiado (e.g., barras, líneas) y me lo presente como una imagen dentro de la respuesta del chat, junto con el texto explicativo, para facilitar mi comprensión. (Corresponde principalmente a RF17, RF18, RF19, RF20, RF21, RF22-integración, RF28-visualización)
		
		\textbf{Precondiciones:}
		\begin{itemize}
			\item El flujo de HU:09 está en progreso.
			\item El Agente Contextualizador identifica que la consulta/datos justifican un gráfico (RF17).
			\item Los datos necesarios para el gráfico están disponibles y estructurados.
			\item El Agente PandasAi esta disponible para la generación de gráficas.
		\end{itemize}
		
		\textbf{Flujo de acción (continuación de HU:09):}
		\begin{enumerate}
			\item Agente Contextualizador determina necesidad de gráfico y formula instrucciones (tipo, datos) (RF17, RF18).
			\item Agente Contextualizador invoca al Agente PandasAi con las instrucciones.
			\item Agente PandasAi genera el script de Pandas para crear el gráfico (RF19).
			\item Agente PandasAi valida la sintaxis y lógica básica del script (RF20).
			\item Agente PandasAi ejecuta el script validado para generar la imagen del gráfico (e.g., PNG) (RF21).
			\item Agente PandasAi devuelve la imagen (o una referencia a ella) al Agente Contextualizador/Moderador.
			\item Agente Contextualizador/Moderador integra la imagen junto con la respuesta textual en la estructura preliminar (RF22).
			\item (Continúa flujo de HU:09) Validación (RF23), Ensamblaje (RF24), Retorno al \textit{backend} (RF25).
			\item (Flujo de HU:08) \textit{Backend} envía URL/datos de imagen al \textit{frontend}.
			\item \textit{Frontend} muestra la imagen recibida dentro del chat (RF28).
		\end{enumerate}
	}
	\storyobservation{
		La detección de la necesidad de un gráfico debe ser fiable (RF17). La generación del script debe ser segura (evitar ejecución de código arbitrario). La validación del script (RF20) es importante para evitar errores en tiempo de ejecución. Los gráficos deben ser claros y legibles. Considerar formatos de imagen web-friendly (PNG, JPG, SVG).
	}
	\storyinterface{Visualización de imagen (gráfico) dentro del Chat en el sitio web, junto al texto explicativo.}
	
\end{userstory}

Las historias de usuario presentadas detallan los requerimientos funcionales del sistema desde la perspectiva del usuario, abarcando desde la gestión de usuarios y autenticación hasta la interacción con el chat y la generación de respuestas textuales y gráficas por parte del microservicio MAS. Estas historias no solo especifican el comportamiento esperado del sistema, sino que también establecen una base clara para el diseño y desarrollo del software, asegurando que las necesidades del usuario se traduzcan en funcionalidades concretas.



\subsection{Tarjetas CRC}

Las tarjetas CRC (Clase-Responsabilidad-Colaboración) son una herramienta de diseño de software orientado a objetos, creada por Kent Beck y Ward Cunningham. Estas tarjetas se utilizan para identificar las clases, sus responsabilidades y cómo colaboran con otras clases para cumplir tareas específicas en un sistema \cite{BeckCunningham}. La representación del sistema multiagente y su interfaz gráfica mediante tarjetas CRC permite estructurar de forma clara y concisa las clases que lo componen, sus responsabilidades específicas y las colaboraciones necesarias para cumplir sus objetivos. Esta técnica facilita la comprensión del comportamiento de cada agente dentro del sistema —como el coordinador, el buscador de información o el generador de respuestas—, promoviendo un diseño orientado a objetos coherente, reutilizable y fácil de mantener. Además, al emplearse en etapas tempranas del desarrollo, las tarjetas CRC fortalecen la comunicación entre desarrolladores y respaldan la validación del modelo antes de su implementación definitiva.

\begin{longtable}{|l|l|}
	\caption{Tarjeta CRC: Agente Moderador} \label{tablacrc1} \\
	
	\hline
	\multicolumn{2}{|c|}{\textbf{Tarjeta CRC}} \\
	\hline
	\textbf{Clase} & \textbf{Agente Moderador} \\
	\hline
	\endfirsthead
	
	\hline
	\textbf{Responsabilidad} & \textbf{Colaboración} \\
	\hline
	\endhead
	
	\hline
	\multicolumn{2}{|r|}{Continúa en la próxima página} \\
	\hline
	\endfoot
	
	\hline
	\endlastfoot
	
	\parbox[t]{0.45\linewidth}{\textbf{Responsabilidades:} \\ 
		Recibir la consulta del usuario \\ 
		Extraer palabras clave e identificar la intención \\ 
		Coordinar el flujo de información entre agentes \\ 
		Ensamblar y entregar la respuesta final al usuario} 
	& 
	\parbox[t]{0.45\linewidth}{\textbf{Colaboración:} \\
		Agente PandasAi \\ 
		Agente recuperador de información (FAISS)\\
		Agente Contextualizador \\ 
		Agente de Validación}
\end{longtable}


\begin{longtable}{|l|l|}
	\caption{Tarjeta CRC: Agente recuperador de información (FAISS) } \label{tablacrc2} \\
	
	\hline
	\multicolumn{2}{|c|}{\textbf{Tarjeta CRC}} \\
	\hline
	\textbf{Clase} & \textbf{Agente recuperador de información (FAISS)} \\
	\hline
	\endfirsthead
	
	\hline
	\textbf{Responsabilidad} & \textbf{Colaboración} \\
	\hline
	\endhead
	
	\hline
	\multicolumn{2}{|r|}{Continúa en la próxima página} \\
	\hline
	\endfoot
	
	\hline
	\endlastfoot
	
	\parbox[t]{0.45\linewidth}{\textbf{Responsabilidades:} \\ 
		Convertir las palabras clave en \textit{embeddings} \\ 
		Consultar la base de datos vectorial para recuperar la información relevante \\ 
		Devolver los resultados al Agente Moderador} 
	& 
	\parbox[t]{0.45\linewidth}{\textbf{Colaboración:} \\
		Agente Moderador \\ 
		Base de datos vectorial}
\end{longtable}

\begin{longtable}{|l|l|}
	\caption{Tarjeta CRC: Agente Contextualizador} \label{tablacrc3} \\
	
	\hline
	\multicolumn{2}{|c|}{\textbf{Tarjeta CRC}} \\
	\hline
	\textbf{Clase} & \textbf{Agente Contextualizador} \\
	\hline
	\endfirsthead
	
	\hline
	\textbf{Responsabilidad} & \textbf{Colaboración} \\
	\hline
	\endhead
	
	\hline
	\multicolumn{2}{|r|}{Continúa en la próxima página} \\
	\hline
	\endfoot
	
	\hline
	\endlastfoot
	
	\parbox[t]{0.45\linewidth}{\textbf{Responsabilidades:} \\ 
		Recibir la información relevante y la intención del usuario \\ 
		Generar indicaciones de estadísticas o contextualizar la información según la petición del usuario \\ 
		Enviar la información procesada al Agente Moderador} 
	& 
	\parbox[t]{0.45\linewidth}{\textbf{Colaboración:} \\
		Agente Moderador \\ 
		Agente PandasAi}
\end{longtable}


\begin{longtable}{|l|l|}
	\caption{Tarjeta CRC: Agente de Validación} \label{tablacrc4} \\
	
	\hline
	\multicolumn{2}{|c|}{\textbf{Tarjeta CRC}} \\
	\hline
	\textbf{Clase} & \textbf{Agente de Validación} \\
	\hline
	\endfirsthead
	
	\hline
	\textbf{Responsabilidad} & \textbf{Colaboración} \\
	\hline
	\endhead
	
	\hline
	\multicolumn{2}{|r|}{Continúa en la próxima página} \\
	\hline
	\endfoot
	
	\hline
	\endlastfoot
	
	\parbox[t]{0.45\linewidth}{\textbf{Responsabilidades:} \\ 
		Revisar la coherencia de la respuesta generada por el sistema \\ 
		Comparar la respuesta con la entrada original \\ 
		Validar o rechazar la respuesta antes de enviarla al usuario} 
	& 
	\parbox[t]{0.45\linewidth}{\textbf{Colaboración:} \\
		Agente Moderador \\ 
		Agente Contextualizador}
\end{longtable}

\begin{longtable}{|l|l|}
	\caption{Tarjeta CRC: Agente PandasAi} \label{tablacrc5} \\
	
	\hline
	\multicolumn{2}{|c|}{\textbf{Tarjeta CRC}} \\
	\hline
	\textbf{Clase} & \textbf{Agente PandasAi} \\
	\hline
	\endfirsthead
	
	\hline
	\textbf{Responsabilidad} & \textbf{Colaboración} \\
	\hline
	\endhead
	
	\hline
	\multicolumn{2}{|r|}{Continúa en la próxima página} \\
	\hline
	\endfoot
	
	\hline
	\endlastfoot
	
	\parbox[t]{0.45\linewidth}{\textbf{Responsabilidades:} \\ 
		Generar un \textit{script} de Pandas para representar estadísticas gráficas cuando sea necesario \\ 
		Validar el \textit{script} y asegurarse de que sea correcto \\ 
		Convertir el gráfico generado en una imagen que pueda ser integrada en la respuesta final\\
		Hacer consultas al CSV cargado para hacer análisis profundos de datos.} 
	& 
	\parbox[t]{0.45\linewidth}{\textbf{Colaboración:} \\
		Agente Contextualizador \\ 
		}
\end{longtable}

En este documento se incluyen ejemplos representativos de algunas de las tarjetas CRC más relevantes para el desarrollo de la solución propuesta. Sin embargo, debido a su extensión, se remite al \textit{Anexo B} para consultar el conjunto completo de las tarjetas CRC, donde se detallan todas las clases identificadas, sus responsabilidades y los colaboradores correspondientes.

\section{Diseño de la propuesta de solución}

\subsection{Diseño de la arquitectura}

La arquitectura propuesta adopta el estilo de \emph{microservicios}, en el cual la aplicación se descompone en un conjunto de servicios independientes, cada uno ejecutándose en su propio proceso y comunicándose mediante protocolos API REST~\cite{turn0search0,turn0search9}. Cada microservicio se orienta a una capacidad de negocio específica, lo que facilita la comprensión y el mantenimiento aislado de los componentes~\cite{turn0search6,turn0search0}. La modularidad inherente a este enfoque permite el despliegue automatizado e independiente de cada servicio, mejorando la agilidad operativa y reduciendo el tiempo de inactividad asociado a las actualizaciones \cite{turn0search8,turn0search3}. La escalabilidad horizontal se ve potenciada, dado que cada servicio puede replicarse de forma autónoma según la demanda, optimizando el uso de recursos y posibilitando un dimensionamiento granular \cite{turn0search3,turn1search0}. El desacoplamiento entre servicios incrementa la tolerancia a fallos, ya que la interrupción de un componente no compromete la disponibilidad del sistema global \cite{turn0search2,turn0search6}. La heterogeneidad tecnológica está plenamente soportada, puesto que cada microservicio puede implementarse con los lenguajes y frameworks más adecuados para su responsabilidad particular \cite{turn0search6,turn1search8}.

\begin{figure}[htbp] 
	\centering
	\includegraphics[width=1\textwidth]{images/Arquitectura.png} 
	\caption{Arquitectura de microservicios del sistema multiagente (Fuente: elaboración propia).}
	\label{fig:erquitectura_MAS}
\end{figure}

La presente configuración arquitectónica se materializa en tres componentes principales como se puede visualizar en la Figura \ref{fig:erquitectura_MAS}:
  
\begin{enumerate}
	\item Un frontend desarrollado con React, encargado de la interacción con el usuario.  
	\item Un backend construido con Django REST Framework, que actúa como orquestador de la lógica de negocio y gestor de peticiones.  
	\item Un microservicio especializado en procesamiento de lenguaje natural, implementado con FastAPI, que alberga el sistema multiagente conversacional.  
\end{enumerate}

Esta elección garantiza la independencia en el ciclo de vida de cada servicio, promoviendo la mantenibilidad y facilitando la incorporación de nuevas tecnologías o la sustitución de componentes sin afectar al sistema global \cite{turn0search1,turn1search4}.

\subsection{Diseño del modelo de datos}

\begin{figure}[htbp] 
	\centering
	\includegraphics[width=1\textwidth]{images/modelo.png} 
	\caption{Diseño del modelo de datos (Fuente: elaboración propia).}
	\label{fig:modelo_de_datos}
\end{figure}


El modelo de datos propuesto en la Figura \ref{fig:modelo_de_datos} articula de manera coherente la estructura relacional necesaria para soportar un sistema de chat en tiempo real~\cite{Codd1970}. Se fundamenta en los principios del modelo relacional que establecen las bases para el almacenamiento y la recuperación eficiente de datos, garantizando la unicidad de las tuplas y la ausencia de redundancia innecesaria~\cite{Silberschatz2019}.\\
La definición de la entidad Usuario contempla un identificador único uid, atributos de autenticación y perfil, así como indicadores de estado y marcas temporales de creación y modificación, satisfaciendo los requerimientos de integridad y auditoría en el dominio de usuario~\cite{ElmasriNavathe2010}. La elección de tipos de datos VARCHAR para los campos característicos responde a la flexibilidad necesaria para posibles extensiones en los identificadores y datos personales~\cite{Date2003}.\\
La entidad Sala de chat permite agrupar conversaciones de manera lógica y filtrable~\cite{ConnollyBegg2014}. Al establecer una relación de uno a muchos con la entidad Usuario a través de la clave foránea registered\_by, se refuerza la trazabilidad de la creación y administración de espacios de comunicación~\cite{Harrington2015}.\\
La entidad Mensajes está diseñada para almacenar cada mensaje asociado a una sala de chat, con su propio identificador, estado de actividad, contenido textual, atributos de rol y metadatos adicionales que facilitan la moderación y la representación multimodal~\cite{Silberschatz2019}. La implementación de la clave foránea chat\_room garantiza la integridad referencial, evitando mensajes huérfanos y asegurando la coherencia de las interacciones~\cite{IBMReferential}.\\
El diseño enfatiza la normalización hasta la tercera forma normal, minimizando anomalías de actualización y duplicación de datos~\cite{Silberschatz2019}. Asimismo, la adopción de métodos ágiles para el modelado de datos respalda iteraciones rápidas y adaptativas durante el ciclo de vida del desarrollo~\cite{Ambler2003}. La adherencia al estándar SQL definido en ISO/IEC 9075 certifica la interoperabilidad en entornos heterogéneos de bases de datos~\cite{ISO9075}.Finalmente, la consideración de criterios de escalabilidad y rendimiento se inspira en lecciones históricas sobre arquitecturas de sistemas de datos~\cite{Stonebraker2005}.


\section{Implementación}

\subsection{Estándares de codificación en Python y JavaScript}

Los estándares de codificación son esenciales para garantizar la mantenibilidad, colaboración y calidad del software~\cite{PEP8}. En este epígrafe se analiza comparativamente las convenciones principales para Python y JavaScript, destacando sus similitudes y diferencias fundamentales.

\subsubsection{Estándares para Python}

\begin{enumerate}
	\item \textbf{Convenciones de Estilo}: Python cuenta con una guía oficial de estilo denominada PEP 8~\cite{PEP8}, que establece directrices precisas para la escritura de código. La indentación de 4 espacios (prohibiendo el uso de tabuladores) y el límite de 79 caracteres por línea son dos de sus reglas más características. El espaciado alrededor de operadores y la organización de imports en tres grupos (bibliotecas estándar, terceros y locales) promueven la consistencia visual. La nomenclatura sigue patrones específicos: \texttt{snake\_case} para funciones y variables, \texttt{PascalCase} para clases, y \texttt{MAYÚSCULAS} para constantes. La documentación mediante docstrings (siguiendo PEP 257~\cite{PEP257}) facilita la generación automática de documentación técnica.
	\item \textbf{Herramientas y Prácticas}: El ecosistema Python ofrece herramientas como \texttt{flake8} para verificación de estilo y \texttt{black} para formateo automático. El uso de \textit{type hints} (desde Python 3.5) mejora la seguridad de tipos en proyectos complejos. El manejo de excepciones debe ser explícito, evitando cláusulas \texttt{except} genéricas que puedan ocultar errores.
\end{enumerate}

\subsubsection{Estándares para JavaScript}

\begin{enumerate}
	\item \textbf{Guías de Referencia}: JavaScript carece de un estándar oficial único, pero guías como el Airbnb JavaScript Style Guide~\cite{AirbnbJS} y Google JavaScript Style Guide~\cite{GoogleJS} se han consolidado como referencias. Estas enfatizan el uso de ES6+, con preferencia por \texttt{const/let} sobre \texttt{var}, y arrow functions para callbacks.\\
	La convención de nombres utiliza \texttt{camelCase} para variables/funciones y \texttt{PascalCase} para clases. Los literales de plantilla (template strings) son preferidos sobre concatenación manual, y el punto y coma sigue siendo opcional pero debe usarse consistentemente.
	\item \textbf{Ecosistema Moderno}: Herramientas como ESLint (configurable con reglas específicas) y Prettier automatizan la aplicación de estándares. El sistema de módulos ES6 (\texttt{import/export}) ha reemplazado ampliamente a \texttt{require} en proyectos nuevos. Para proyectos complejos, TypeScript ofrece tipado estático, reduciendo errores en tiempo de ejecución~\cite{TypeScript}.
\end{enumerate}

Ambos lenguajes comparten principios fundamentales: modularización del código, documentación clara, y uso de linters. Python muestra mayor uniformidad gracias a PEP 8, mientras JavaScript permite más flexibilidad mediante guías configurables. En rendimiento, JavaScript prioriza la compatibilidad con navegadores, mientras Python enfatiza la legibilidad como principio filosófico~\cite{PEP20}. La adopción de estándares debe adaptarse al contexto del proyecto y equipo, utilizando herramientas automatizadas para garantizar cumplimiento. Tanto Python como JavaScript han desarrollado ecosistemas maduros que, cuando se usan consistentemente, elevan sustancialmente la calidad del código.

\subsection{Patrones de diseño}
\label{sec:patrones_diseno}

Los patrones de diseño de software representan soluciones probadas y estandarizadas para problemas recurrentes en el desarrollo, encapsulando mejores prácticas y promoviendo la creación de software modular, legible, flexible y robusto \cite{gavilanez2022analisis}. En el desarrollo de esta aplicación web y su microservicio asociado, se han aplicado conscientemente varios patrones para abordar los desafíos inherentes a su arquitectura distribuida y su flujo de trabajo basado en IA. A continuación, se analizan algunos de los patrones de diseño a implementar en el sistema multiagente conversacional y en el \textit{backend} (desarrollado con Django REST Framework), destacando su relevancia y su impacto en el procesamiento de datos históricos del \textit{Diario de la Marina}.

\textbf{Patrón Singleton} se utiliza para gestionar recursos críticos compartidos en el sistema multiagente, asegurando que componentes como la base de datos históricos, el índice FAISS para la base de datos vectorial, y los agentes tengan una única instancia en toda la aplicación. Este patrón es fundamental para optimizar el uso de recursos, ya que evita la creación redundante de instancias pesadas, lo que podría impactar negativamente el rendimiento del sistema, especialmente al procesar grandes volúmenes de datos históricos del \textit{Diario de la Marina}. La Figura \ref{fig:codigo_singleton} muestra un extracto de este código, evidenciando la implementación del patrón.\\
La importancia del patrón \textit{Singleton} radica en su capacidad para centralizar el acceso a recursos compartidos, reduciendo la sobrecarga computacional y asegurando consistencia en los datos procesados. Esto es particularmente relevante en un sistema multiagente, donde múltiples agentes (como \texttt{AgenteRecuperador} y \texttt{AgentePandasAi}) necesitan acceder a las mismas estructuras de datos para generar respuestas textuales o gráficas.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/singleton.PNG}
	\caption{Extracto de código que implementa el patrón (Fuente: elaboración propia). \textit{Singleton}.}
	\label{fig:codigo_singleton}
\end{figure}

\textbf{Patrón Cadena de responsabilidad} permite que el sistema multiagente implemente un flujo de trabajo estructurado, que orqueste la ejecución de agentes a través de un grafo de estados. Este patrón permite que cada agente (como el moderador, el contextualizador, el ejecutor PandasAI, y el validador) procese y modifique un estado compartido, pasando el control al siguiente agente en la cadena. Esta estructura es esencial para manejar consultas complejas que requieren el procesamiento conjunto de datos estructurados (del archivo CSV) y no estructurados (de la base vectorial), como se describe en la Figura \ref{fig:codigo_workflow}.\\ 
La relevancia de este patrón radica en su capacidad para modularizar el flujo de procesamiento, permitiendo que cada agente se especialice en una tarea específica. Esto no solo facilita el mantenimiento y la extensibilidad del sistema, sino que también asegura que las consultas se procesen de manera eficiente, cumpliendo con los requisitos funcionales relacionados con la generación de respuestas.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/cadena.PNG}
	\caption{Extracto de código que implementa el patrón \textit{Cadena de responsabilidad} (Fuente: elaboración propia).}
	\label{fig:codigo_workflow}
\end{figure}

\textbf{Patrón Plantilla Abstracta} permite estandarizar comportamientos comunes en modelos, serializadores y paginaciones. Este patrón permite definir una estructura general que puede ser heredada y personalizada por clases específicas, promoviendo la reutilización de código y facilitando el mantenimiento del sistema. La Figura \ref{fig:codigo_template_method} muestra un extracto de este código.\\
La importancia del patrón \textit{Plantilla Abstracta} en este contexto radica en su capacidad para reducir la duplicación de código y garantizar consistencia en la estructura de los datos manejados por el \textit{backend}. Esto es crucial en un sistema que orquesta múltiples microservicios, ya que asegura que las respuestas enviadas al \textit{frontend} sean uniformes y que los modelos de datos sean fácilmente extensibles para futuras funcionalidades.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/codigo_template_method.png}
	\caption{Extracto de código que implementa el patrón \textit{Plantilla Abstracta} (Fuente: elaboración propia).}
	\label{fig:codigo_template_method}
\end{figure}

\textbf{Patrón Fachada} permite simplificar la interacción con subsistemas complejos, encapsulando la lógica de manejo de mensajes y respuestas en clases específicas. Este patrón permite abstraer operaciones complejas, como el formateo de mensajes o la gestión de respuestas de un modelo de lenguaje, en una interfaz sencilla que puede ser utilizada por otras partes del sistema. La Figura \ref{fig:codigo_facade} muestra ejemplo de la implementación de este patrón.\\
La relevancia del patrón \textit{Facade/Service} radica en su capacidad para reducir la complejidad del backend, permitiendo que los controladores de Django REST Framework se centren en la lógica de negocio mientras las clases de servicio manejan las operaciones más técnicas. Esto mejora la modularidad y facilita la integración con el sistema multiagente, asegurando que las respuestas generadas por el Microservicio MAS se procesen y entreguen al frontend de manera eficiente.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{images/fachada.PNG}
	\caption{Extracto de código que implementa el patrón \textit{Fachada} (Fuente: elaboración propia).}
	\label{fig:codigo_facade}
\end{figure}

El uso de estos patrones de diseño en el sistema multiagente y el backend no solo asegura una implementación robusta y escalable, sino que también facilita la transformación de datos históricos del \textit{Diario de la Marina} en conocimiento estructurado, cumpliendo con los objetivos del proyecto.



\subsection{Interfaz Principal del Sistema}

La figura \ref{fig:interfaz} muestra la interfaz principal del sistema multiagente, diseñado para permitir la interacción en lenguaje natural con datos históricos del \textit{Diario de la Marina}. A continuación, se detalla cada uno de los componentes numerados de la interfaz:

\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{images/interfaz1.png}
	\caption{Interfaz principal del chat con el sistema multiagente (Fuente: elaboración propia)}
	\label{fig:interfaz}
\end{figure}

\begin{enumerate}[label=\textbf{\arabic*.}]
	\item \textbf{Botón de Nuevo Chat}: ubicado en la parte superior izquierda, este botón permite al usuario iniciar una nueva conversación. Al activarse, se borra la conversación actual y se prepara el sistema para recibir una nueva consulta.
	
	\item \textbf{Panel de Historial de Conversaciones}: muestra una lista cronológica de conversaciones anteriores. Cada elemento incluye el título de la conversación (asignado automáticamente o manualmente) y un menú contextual para acciones como renombrar o eliminar. Esta sección permite retomar diálogos previos de forma eficiente.
	
	\item \textbf{Información del Usuario}: en la parte inferior del panel lateral se muestra el correo electrónico del usuario autenticado. Incluye un botón para copiar fácilmente la dirección, facilitando su reutilización o verificación de sesión.
	
	\item \textbf{Área de Entrada de Consulta}: permite al usuario redactar y enviar preguntas o mensajes. El campo de texto cuenta con una sugerencia que invita a interactuar: \textit{¿Qué quieres saber hoy?}. Incluye un botón de envío que ejecuta la solicitud hacia el sistema conversacional.
	
\end{enumerate}

\subsection{Diagrama de despliege}

Los diagramas de despliegue muestran cómo los componentes de software se despliegan
físicamente en los procesadores; es decir, el diagrama de despliegue muestra el hardware
y el software en el sistema, así como el middleware~\footnote{Middleware, también conocido como lógica de intercambio de información entre aplicaciones o agente intermedio, es un sistema de software que ofrece servicios y funciones comunes para las aplicaciones.} usado para conectar los diferentes
componentes en el sistema. En esencia, los diagramas de despliegue se pueden considerar
como una forma de definir y documentar el entorno objetivo~\cite{sommerville2011software}.\\
A continuación, la figura~\ref{fig:despliege}. muestra el diagrama correspondiente al sistema propuesto.\\
\textbf{Nodos:} elementos de procesamiento con al menos un procesador, memoria, y posiblemente otros dispositivos.\\
\textbf{Dispositivos:} nodos estereotipados sin capacidad de procesamiento en el nivel de abstracción que se modela.\\
\textbf{Conectores:} expresa el tipo de conector o protocolo utilizado entre el resto de los elementos del modelo.\\

\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{images/despliege.drawio.png}
	\caption{Representación del modelo de despliegue. (Fuente: elaboración propia).}
	\label{fig:despliege}
\end{figure}

\textbf{Dispositivo del cliente}: Se refiere a el conjunto de todos los clientes que consumirán el software desde sus computadoras. La máquina cliente necesita de muy pocas
prestaciones; teniendo un navegador web (Chrome, Mozilla Firefox, Internet Explorer,Opera), una RAM mínima de 4 GB, una tarjeta de red y un procesador mínimo de 3.3 GB podrá acceder al sistema y realizar las operaciones necesarias\\
\textbf{Servidor Web}: Representa el servidor que se comunica con la PC Cliente mediante el protocolo HTTPS y además realiza peticiones al servidor de Bases de Datos mediante el protocolo TCP/IP, es el encargado de la presentación del repositorio, debe estar compuesto de 32 GB de RAM, 1 TB de almacenamiento, un procesador de 3.3 GHz o superior, una tarjeta de red, servidor web Nginx o Treafic con Docker.\\
\textbf{Servidor de BD}: Elemento de cómputo, dedicado a almacenar y proveer datos necesarios para el funcionamiento de la aplicación web. es el encargado de almacenar la información generada del
sistema, para el correcto funcionamiento del repositorio es necesario que posea PostgreSQL, una RAM mínima de 4 GB, un procesador mínimo de 3.3 GHz y un disco duro de 1 TB.\\

\section*{Conclusiones del capítulo}
\addcontentsline{toc}{section}{Conclusiones}

El capítulo 2 presenta un enfoque metodológico y técnico para abordar la interpretación de datos históricos no estructurados del Diario de la Marina, integrando metodologías ágiles, arquitecturas multiagente y tecnologías emergentes. La aplicación de Extreme Programming permitió adaptar el desarrollo a las necesidades identificadas en usuarios especializados, como historiadores, priorizando la corrección de errores de OCR y la contextualización de respuestas. La arquitectura propuesta, basada en microservicios y agentes especializados (Moderador, Recuperador, Contextualizador), mostró potencial para gestionar la complejidad de los datos mediante la coordinación de tareas como la recuperación semántica con FAISS y la generación de visualizaciones dinámicas.

La selección de herramientas como LangChain, modelos de embeddings y bases de datos vectoriales contribuyó a optimizar la precisión en el procesamiento de consultas, mientras que patrones de diseño como Singleton y Cadena de Responsabilidad reforzaron la mantenibilidad del sistema. La interfaz, diseñada para facilitar la interacción con usuarios no técnicos, combinó un historial de conversaciones y visualizaciones gráficas, evidenciando la viabilidad de transformar datos históricos en conocimiento accesible.

Este enfoque sugiere un avance en el campo de la informática histórica, al proponer un marco replicable que integra sistemas multiagente con IA generativa, adaptable a otros contextos de patrimonio digital. Las decisiones técnicas, respaldadas por un proceso iterativo y centrado en el usuario, reflejan una solución equilibrada entre innovación y aplicabilidad práctica, sentando bases para futuras validaciones experimentales y ampliaciones del sistema.
